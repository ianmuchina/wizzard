# Exercise 1.9:

## Question

Each of the following two procedures defines a method for adding two positive integers in terms of the procedures inc, which increments its argument by 1, and dec, which decrements its argument by 1.

```scheme
(define (+ a b)
  (if (= a 0)
      b
      (inc (+ (dec a) b))))

(define (+ a b)
  (if (= a 0)
      b
      (+ (dec a) (inc b))))
```

Using the substitution model, illustrate the process generated by each procedure in evaluating (+ 4 5). Are these processes iterative or recursive?

## Answer

Looking at the 2 code samples, they are the same with only one difference

```racket
;Example 1
(inc (add (dec a) b))
;Example 2
(add (dec a) (inc b))
```

I'm not used to prefix notation so i converted the code to a more familiar style.

```js
//Example 1
return inc(add(dec(a), b));
//Example 2
return add(dec(a), inc(b));
```

Modelling it looks like this.

```js
add(4, 5);
inc(add(3, 5));
inc(inc(add(2, 5)));
inc(inc(inc(add(1, 5))));
inc(inc(inc(inc(add(0, 5)))));
//Triggers base case
inc(inc(inc(inc(5))));
inc(inc(inc(6)));
inc(inc(7));
inc(8);
9;
```

```c
add(4, 5);
add(3, 6);
add(2, 7);
add(1, 8);
add(0, 9);
```

answer: they are both recursive in that they call themselves. the first uses more space, the second uses less space & time and is perfect for tail call optimization.

## extra

This isn't important to the question but interesting.

I rewrote the second solution in c to visualize the code better (lisp is ugly). The goal was to learn more about tail call optimization as i don't have lots of knowledge on the low level computer concepts.

You can disable all optimizations with the `-O0` flag. With the optimizations disabled, the code run out of stack space causing a segmentation fault. Apparently, stack space is limited and not designed to be large. (It's only 8kb!).

Clueless as to why the max stack size is that small, I increased it? After all i have way more than 8kb of memory. Does that work? Nope. I doubled the maximum stack size with `ulimit -s` to 8mb. That didn't go well. My computer froze forcing me to reboot.

## Conclusion

don't use recursion on langiages without Tail call optimization. a while loop is what you want.

## Resources i used

[Answer on codology.net](https://codology.net/post/sicp-solution-exercise-1-9/) - is this cheating??
[[Video]Tail Call Optmisation with GCC](dis) - Very good video. Even goes a little into assembly.
